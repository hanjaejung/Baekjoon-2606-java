# Baekjoon-2606-java
백준 2606 자바 bfs, dfs

bfs, dfs 알고리즘 공부하며 푼것에 대해 글을 남깁니다

​

사실 bfs, dfs를 익히기 위해 관련된 문제를 계속 푸는중입니다

​

처음에는 어려웠지만 다른분들이 푸시는걸 직접 디버깅하면서 풀어서 답을 보고 풀더라도 거의 완전히 이해된 상태에서 풀어서 풀수록 점점 문제가 이해가 되고 있어서 상당히 뿌듯한 느낌이 듭니다

​

일단 bfs, dfs를 현재까지 풀면서 느낌점은 루트가 왠만하면 거의다 1로 시작합니다. 이번 문제도 마찬가지로 1번 컴퓨터가 바이러스가 걸렸다는 가정이니 1번으로 시작하네요

​

아직 공부가 완전히 되지 않아 bfs, dfs에 대해 간략히 설명드리자면

bfs는 한놈만 팬다는 느낌? 즉 하나의 경우의수가 완전히 끝난 후 다음 경우의 수를 탐색하는걸 의미하며

dfs는 한쪽을 깊이 판 후 다음 경우의 수를 찾는 느낌입니다

​

대략적 bfs, dfs 공통적인 방법으로는 하나의 큰 그래프를 만들어

담을 배열을 몇차원으로 할지 정하며

방문했는지 안했는지 boolean이 필요한 정도네요

​

총 컴퓨터의 수가 7개이니 0 ~ 7의 x, y 좌표를 아래와 같이 만든 후

컴퓨터 쌍의 수 대로 좌표를 표시하면

1 2 세로 1에서 가로 2인 좌표이니 이렇게 표시 => 0 0 1 0 0 0 0 0

2 3 세로 2에서 가로 3인 좌표이니 이렇게 표시 =>  0 1 0 1 0 0 0 0

~

​

이런식으로 계속 표시하면 아래와 같이 되는데 참고로 하나 더 추가하자면

1 2 => 0 0 1 0 0 0 0 0 이런식으로 구할시

반대로 2 1도 구해야 해서

  0 0 0 0 0 0 0 0

  0 0 1 0 0 0 0 0

  0 1 => 여기 1에도 표시 되어야 한다는 뜻입니다 즉 쌍으로 한번 더 생성해야 합니다

​

좌표를 다표현하면 이런식으로 되어있을겁니다

0 0 0 0 0 0 0 0  0   예) 2 ->    5 ->         6 ->          2

0 0 1 0 0 1 0 0  1    2 5 5는 셋으니 밑에인 2로 돌아간다 2가 큐에 남았기 때문이다

0 1 0 1 0 0 0 0  2    그러면 0 1 0 1 이 쓰여긴것에서 마지막1인 3번째를 센다

0 0 1 0 0 0 0 0  3

0 0 0 0 0 0 0 1  4

0 0 0 0 0 0 1 0  5

0 0 0 0 0 1 0 0  6

0 0 0 0 1 0 0 0  7

​

이런식으로 좌표를 생성 후 bfs나 dfs의 방법을 이용해서 탐색한 후 답을 찾아내는 형식입니다

​

원래는 탐색방법에 대해 많이 깨달은 부분이 있어 탐색방법에 대해서도 적으려했으나 너무 길고 글을 쓰는데 읽는 사람입장도 지겨울거 같고 가독성이 많이 떨어질거 같습니다

​

그래서 아래의 소스를 디버깅하여 개인적으로 알아내서 앞으로 문제 푸실때 자신만의 노하우를 알아내시는게 훨씬 도움되실 겁니다
